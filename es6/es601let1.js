// let 是代码块有效,var是在全局范围内有效:
{
    let a=0;
    var b=1 
}   
// console.log(a)
console.log(b)
// 变量i是var声明的,在全局范围内有效,
// 在 JavaScript 中，`setTimeout` 函数创建了一个函数（闭包），它保持对外部作用域的引用。这个外部作用域包括循环变量 `i`。当 `setTimeout` 的回调函数最后执行时，它看到的 `i` 的值是循环结束时的值，也就是 `10`。

// 这种行为是因为 JavaScript 中的 `var` 关键字没有块级作用域。在这个例子中，`i` 实际上是全局作用域（或者说是包含这个循环的函数的作用域）的变量，而不是循环块的局部变量。因此，当你的 `setTimeout` 回调函数运行时，`for` 循环已经完成，`i` 的值已经变成了 `10`。

// 你可以使用 `let` 关键字来替代 `var`，因为 `let` 在块级作用域（如一个循环或一个 `if` 语句）中定义的变量在块的外部是不可见的。这样，每次循环迭代都会创建一个新的 `i` 变量，`setTimeout` 的每个回调函数都会看到他们各自的 `i` 值。

// 下面是修复后的代码：

// ```javascript
// for(let i =0;i<10;i++){
//     setTimeout(function(){
//         console.log(i)
//     })
// }
// ```

// 在这个版本中，每次迭代都会创建一个新的 `i` 变量，因此每个 `setTimeout` 回调看到的 `i` 的值都是它们各自的迭代步骤中的值，而不是循环结束后的值。因此，这个版本会打印出 `0` 到 `9`，而不是 `10`。
for(var i =0;i<10;i++){
    // console.log(i)
    setTimeout(function(){
        console.log(i)
    })
}

// 这是因为JavaScript采用的是基于事件循环的并发模型，这种模型中，一些代码（如 `setTimeout`，`setInterval` 或 AJAX 请求等）是异步执行的，这意味着它们不会立即执行，而是在当前执行栈中的所有同步代码执行完毕后才会执行。

// 在你的代码中，`for` 循环是同步代码，而 `setTimeout` 是异步代码。因此，`for` 循环会首先完全执行，然后所有的 `setTimeout` 回调才会执行。由于 `setTimeout` 没有设置延迟时间，它会尽快执行，但总是在所有同步代码之后。

// 简单来说，`setTimeout` 延迟的不仅仅是它的回调函数，还包括所有的同步代码。这就是为什么在这个例子中，所有的 `setTimeout` 都在 `for` 循环结束后才执行的原因。

// 下面是一个简单的时间线来描述这个过程：

// 1. `for` 循环开始执行。
// 2. 每次迭代，都会调度一个 `setTimeout`，但是这些 `setTimeout` 的回调并不会立即执行，而是被添加到一个队列中等待执行。
// 3. `for` 循环结束后，`i` 的值变为 `10`。
// 4. 此时，所有的同步代码都已经执行完毕，事件循环开始处理队列中的 `setTimeout` 回调。
// 5. 每个 `setTimeout` 回调函数访问变量 `i`，此时 `i` 的值已经是 `10`。

// 这就是为什么所有的 `setTimeout` 回调都打印出 `10` 的原因。

for(let i =0;i<10;i++){
    setTimeout(function(){
        console.log("let 函数的使用",i)
    })

}